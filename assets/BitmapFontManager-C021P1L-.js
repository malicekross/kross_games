import{E as $,d as v,v as B,T as M,f as O,a as I,C as b,R as Y,b as H,I as X,g as L,c as N,e as A,l as U,h as k,w as D}from"./index-DnJsA0dy.js";class G extends ${constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return v(B,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return v(B,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return v(B,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return v(B,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return v(B,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const e in this.chars)this.chars[e].texture?.destroy();this.chars=null,t&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}const K=class R extends G{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...R.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const s=e.style.clone();e.overrideFill&&(s._fill.color=16777215,s._fill.alpha=1,s._fill.texture=M.WHITE,s._fill.fill=null),this.applyFillAsTint=e.overrideFill;const i=s.fontSize;s.fontSize=this.baseMeasurementFontSize;const n=O(s);e.overrideSize?s._stroke&&(s._stroke.width*=this.baseRenderedFontSize/i):s.fontSize=this.baseRenderedFontSize=i,this._style=s,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,e.textureStyle&&(this._textureStyle=e.textureStyle instanceof I?e.textureStyle:new I(e.textureStyle)),this.fontMetrics=b.measureFont(n),this.lineHeight=s.lineHeight||this.fontMetrics.fontSize||s.fontSize}ensureCharacters(t){const e=b.graphemeSegmenter(t).filter(g=>!this._currentChars.includes(g)).filter((g,h,l)=>l.indexOf(g)===h);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let s;this._currentPageIndex===-1?s=this._nextPage():s=this.pages[this._currentPageIndex];let{canvas:i,context:n}=s.canvasAndContext,a=s.texture.source;const r=this._style;let o=this._currentX,p=this._currentY,d=this._currentMaxCharHeight;const u=this.baseRenderedFontSize/this.baseMeasurementFontSize,w=this._padding*u;let x=!1;const S=i.width/this.resolution,m=i.height/this.resolution;for(let g=0;g<e.length;g++){const h=e[g],l=b.measureText(h,r,i,!1);l.lineHeight=l.height;const f=l.width*u,_=Math.ceil((r.fontStyle==="italic"?2:1)*f),W=l.height*u,z=_+w*2,y=W+w*2;if(x=!1,h!==`
`&&h!=="\r"&&h!=="	"&&h!==" "&&(x=!0,d=Math.ceil(Math.max(y,d))),o+z>S&&(p+=d,d=y,o=0,p+d>m)){a.update();const C=this._nextPage();i=C.canvasAndContext.canvas,n=C.canvasAndContext.context,a=C.texture.source,o=0,p=0,d=0}const F=f/u-(r.dropShadow?.distance??0)-(r._stroke?.width??0);if(this.chars[h]={id:h.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:F,kerning:{}},x){this._drawGlyph(n,l,o+w,p+w,u,r);const C=a.width*u,P=a.height*u,E=new Y(o/C*a.width,p/P*a.height,z/C*a.width,y/P*a.height);this.chars[h].texture=new M({source:a,frame:E}),o+=Math.ceil(z)}}a.update(),this._currentX=o,this._currentY=p,this._currentMaxCharHeight=d,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return v(B,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const s=this._measureCache;for(let i=0;i<t.length;i++){const n=t[i];for(let a=0;a<this._currentChars.length;a++){const r=this._currentChars[a];let o=s[n];o||(o=s[n]=e.measureText(n).width);let p=s[r];p||(p=s[r]=e.measureText(r).width);let d=e.measureText(n+r).width,u=d-(o+p);u&&(this.chars[n].kerning[r]=u),d=e.measureText(n+r).width,u=d-(o+p),u&&(this.chars[r].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=H.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const s=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),i=new M({source:new X({resource:e.canvas,resolution:s,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(i.source.style=this._textureStyle);const n={canvasAndContext:e,texture:i};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,s){e.fontSize=this.baseRenderedFontSize,t.scale(s,s),t.font=O(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const i=e._stroke,n=i?.width??0;if(i&&(t.lineWidth=n,t.lineJoin=i.join,t.miterLimit=i.miterLimit,t.strokeStyle=L(i,t)),e._fill&&(t.fillStyle=L(e._fill,t)),e.dropShadow){const a=e.dropShadow,r=N.shared.setValue(a.color).toArray(),o=a.blur*s,p=a.distance*s;t.shadowColor=`rgba(${r[0]*255},${r[1]*255},${r[2]*255},${a.alpha})`,t.shadowBlur=o,t.shadowOffsetX=Math.cos(a.angle)*p,t.shadowOffsetY=Math.sin(a.angle)*p}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,s,i,n,a){const r=e.text,o=e.fontProperties,d=(a._stroke?.width??0)*n,u=s+d/2,w=i-d/2,x=o.descent*n,S=e.lineHeight*n;let m=!1;a.stroke&&d&&(m=!0,t.strokeText(r,u,w+S-x));const{shadowBlur:g,shadowOffsetX:h,shadowOffsetY:l}=t;a._fill&&(m&&(t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0),t.fillText(r,u,w+S-x)),m&&(t.shadowBlur=g,t.shadowOffsetX=h,t.shadowOffsetY=l)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:s}=this.pages[t];H.returnCanvasAndContext(e),s.destroy(!0)}this.pages=null}};K.defaultOptions={textureSize:512,style:new A,mipmap:!0};let j=K;function q(c,t,e,s){const i={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};i.offsetY=e.baseLineOffset;let n=i.lines[0],a=null,r=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},p=e.baseMeasurementFontSize/t.fontSize,d=t.letterSpacing*p,u=t.wordWrapWidth*p,w=t.lineHeight?t.lineHeight*p:e.lineHeight,x=t.wordWrap&&t.breakWords,S=h=>{const l=n.width;for(let f=0;f<o.index;f++){const _=h.positions[f];n.chars.push(h.chars[f]),n.charPositions.push(_+l)}n.width+=h.width,r=!1,o.width=0,o.index=0,o.chars.length=0},m=()=>{let h=n.chars.length-1;if(s){let l=n.chars[h];for(;l===" ";)n.width-=e.chars[l].xAdvance,l=n.chars[--h]}i.width=Math.max(i.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,i.lines.push(n),i.height+=w},g=h=>h-d>u;for(let h=0;h<c.length+1;h++){let l;const f=h===c.length;f||(l=c[h]);const _=e.chars[l]||e.chars[" "];if(/(?:\s)/.test(l)||l==="\r"||l===`
`||f){if(!r&&t.wordWrap&&g(n.width+o.width)?(m(),S(o),f||n.charPositions.push(0)):(o.start=n.width,S(o),f||n.charPositions.push(0)),l==="\r"||l===`
`)m();else if(!f){const F=_.xAdvance+(_.kerning[a]||0)+d;n.width+=F,n.spaceWidth=F,n.spacesIndex.push(n.charPositions.length),n.chars.push(l)}}else{const y=_.kerning[a]||0,F=_.xAdvance+y+d;x&&g(n.width+o.width+F)&&(S(o),m()),o.positions[o.index++]=o.width+y,o.chars.push(l),o.width+=F}a=l}return m(),t.align==="center"?J(i):t.align==="right"?Z(i):t.align==="justify"&&V(i),i}function J(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],s=c.width/2-e.width/2;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=s}}function Z(c){for(let t=0;t<c.lines.length;t++){const e=c.lines[t],s=c.width-e.width;for(let i=0;i<e.charPositions.length;i++)e.charPositions[i]+=s}}function V(c){const t=c.width;for(let e=0;e<c.lines.length;e++){const s=c.lines[e];let i=0,n=s.spacesIndex[i++],a=0;const r=s.spacesIndex.length,p=(t-s.width)/r;for(let d=0;d<s.charPositions.length;d++)d===n&&(n=s.spacesIndex[i++],a+=p),s.charPositions[d]+=a}}function Q(c){if(c==="")return[];typeof c=="string"&&(c=[c]);const t=[];for(let e=0,s=c.length;e<s;e++){const i=c[e];if(Array.isArray(i)){if(i.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(i[0].length===0||i[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=i[0].charCodeAt(0),a=i[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let r=n,o=a;r<=o;r++)t.push(String.fromCharCode(r))}else t.push(...Array.from(i))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}let T=0;class ee{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=U(1e3)}getFont(t,e){let s=`${e.fontFamily}-bitmap`,i=!0;if(e._fill.fill&&!e._stroke?(s+=e._fill.fill.styleKey,i=!1):(e._stroke||e.dropShadow)&&(s=`${e.styleKey}-bitmap`,i=!1),!k.has(s)){const a=Object.create(e);a.lineHeight=0;const r=new j({style:a,overrideFill:i,overrideSize:!0,...this.defaultOptions});T++,T>50&&D("BitmapText",`You have dynamically created ${T} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),r.once("destroy",()=>{T--,k.remove(s)}),k.set(s,r)}const n=k.get(s);return n.ensureCharacters?.(t),n}getLayout(t,e,s=!0){const i=this.getFont(t,e),n=`${t}-${e.styleKey}-${s}`;if(this.measureCache.has(n))return this.measureCache.get(n);const a=b.graphemeSegmenter(t),r=q(a,e,i,s);return this.measureCache.set(n,r),r}measureText(t,e,s=!0){return this.getLayout(t,e,s)}install(...t){let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:t[2]?.chars,resolution:t[2]?.resolution,padding:t[2]?.padding,skipKerning:t[2]?.skipKerning},v(B,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const s=e?.name;if(!s)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const i=e.style,n=i instanceof A?i:new A(i),a=e.dynamicFill??this._canUseTintForStyle(n),r=new j({style:n,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1,textureStyle:e.textureStyle}),o=Q(e.chars);return r.ensureCharacters(o.join("")),k.set(`${s}-bitmap`,r),r.once("destroy",()=>k.remove(`${s}-bitmap`)),r}uninstall(t){const e=`${t}-bitmap`,s=k.get(e);s&&s.destroy()}_canUseTintForStyle(t){return!t._stroke&&(!t.dropShadow||t.dropShadow.color===0)&&!t._fill.fill&&t._fill.color===16777215}}const se=new ee;export{G as A,se as B,q as g};
